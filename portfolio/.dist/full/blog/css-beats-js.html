
    <!doctype html>

    <html lang="en-US">
      <head>
        <title>Why CSS beats CSS-in-JS / Form & Function</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta name="article:published_time" content="Tue Aug 05 2025 05:30:00 GMT+0530 (India Standard Time)">
	<meta name="generator" content="Nue v2.0.0-beta.2 (nuejs.org)">
	<meta name="date.updated" content="2025-12-31T12:50Z">
	<meta name="og:title" content="Why CSS beats CSS-in-JS / Form & Function">
	<meta name="og:description" content="CSS-in-JS promised to solve CSS problems by moving styles into JavaScript. Instead, it created new problems while ignoring the solutions that already exist. Real CSS has evolved past the limitations that drove developers to JavaScript in the first place.">
	<meta name="libs" content="@shared\ui\isomorphic.html">
	<meta name="description" content="CSS-in-JS promised to solve CSS problems by moving styles into JavaScript. Instead, it created new problems while ignoring the solutions that already exist. Real CSS has evolved past the limitations that drove developers to JavaScript in the first place.">
	<meta name="author" content="Emma Bennet">
	<link rel="stylesheet" href="/@shared\design\base.css">
	<link rel="stylesheet" href="/@shared\design\button.css">
	<link rel="stylesheet" href="/@shared\design\components.css">
	<link rel="stylesheet" href="/@shared\design\content.css">
	<link rel="stylesheet" href="/@shared\design\dialog.css">
	<link rel="stylesheet" href="/@shared\design\document.css">
	<link rel="stylesheet" href="/@shared\design\figure.css">
	<link rel="stylesheet" href="/@shared\design\form.css">
	<link rel="stylesheet" href="/@shared\design\layout.css">
	<link rel="stylesheet" href="/@shared\design\modifier.css">
	<link rel="stylesheet" href="/@shared\design\syntax.css">
	<link rel="stylesheet" href="/@shared\design\table.css">
	<script src="/@nue/transitions.js" type="module"></script>
	<script src="/@nue/mount.js" type="module"></script>
	<script type="importmap">{"imports":{"crud":"/@shared/lib/crud.js","admin":"/admin/admin.js","state":"/@nue/state.js"}}</script>
	<link rel="alternate" type="application/rss+xml" title="UX developer blog" href="/feed.xml">
        
      </head>
      
    <body>
      
      <header><nav><a href="/"><div class="logo"><b>■</b> Shubham Mete
</div></a> <a href="/projects/">Projects</a> <a href="/blog/">Blog</a></nav> <nav></nav></header>
      
      
    <main>
      
      
    <article>
      <div><time>Aug 5, 2025</time> • <span>Emma Bennet</span></div>
      <section><h1>Why CSS beats CSS-in-JS</h1>
<p>CSS-in-JS promised to solve CSS problems by moving styles into JavaScript. Instead, it created new problems while ignoring the solutions that already exist. Real CSS has evolved past the limitations that drove developers to JavaScript in the first place.</p>
<figure class="yellow"><div style="--height:400px;"></div></figure></section>

<section><h2>The promise that didn't deliver</h2>
<p>CSS-in-JS emerged from real frustrations. Global namespaces caused conflicts. Unused styles bloated bundles. Dynamic styling felt clunky. The solution seemed obvious: move everything to JavaScript where we have modules, variables, and logic.</p>
<p>But CSS-in-JS didn't solve these problems. It relocated them. Global conflicts became runtime overhead. Unused styles became larger JavaScript bundles. Dynamic styling became complex prop drilling and theme providers.</p>
<p>Meanwhile, CSS kept evolving. Custom properties gave us real variables. Cascade layers eliminated specificity wars. Container queries made components truly responsive. The language that CSS-in-JS tried to replace became the solution.</p></section>

<section><h2>Real problems, wrong solutions</h2>
<p>Every CSS-in-JS library tries to solve legitimate CSS challenges. But they solve yesterday's problems with today's complexity instead of using today's CSS features.</p>
<h3>Scoping and conflicts</h3>
<p><strong>The CSS-in-JS approach:</strong> Generate unique class names at runtime. Add vendor prefixes. Include only used styles.</p>
<pre><code language="jsx"><strong>const</strong> <b>Button</b> <i>=</i> styled<i>.</i>button<i>`</i>
  <b>background</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> props<i>.</i>primary <i>?</i> <em>'#007bff'</em> <i>:</i> <em>'#6c757d'</em><i>}</i><i>;</i>
  <b>color</b><i>:</i> white<i>;</i>
  <b>border</b><i>:</i> none<i>;</i>
  <b>padding</b><i>:</i> <em>0.5rem</em> <em>1rem</em><i>;</i>
<i>`</i></code></pre>
<p><strong>Modern CSS approach:</strong> Use cascade layers and logical organization. Scope with custom properties.</p>
<pre><code language="css"><label>@layer</label> components <i>{</i>
  button <i>{</i>
    <b>background</b><i>:</i> <strong>var</strong><i>(</i><em>--button-bg</em><i>,</i> <strong>var</strong><i>(</i><em>--neutral-600</em><i>)</i><i>)</i><i>;</i>
    <b>color</b><i>:</i> <strong>var</strong><i>(</i><em>--button-text</em><i>,</i> white<i>)</i><i>;</i>
    <b>border</b><i>:</i> none<i>;</i>
    <b>padding</b><i>:</i> <strong>var</strong><i>(</i><em>--space-2</em><i>)</i> <strong>var</strong><i>(</i><em>--space-4</em><i>)</i><i>;</i>
  <i>}</i>

  <b>button</b><i>[</i><b>data-variant</b><i>=</i><em>"primary"</em><i>]</i> <i>{</i>
    <b>background</b><i>:</i> <strong>var</strong><i>(</i><em>--primary-600</em><i>)</i><i>;</i>
  <i>}</i>
<i>}</i></code></pre>
<p>Layers solve specificity problems permanently. Custom properties provide clean theming. No runtime overhead, no build complexity, no vendor lock-in.</p>
<h3>Dynamic styling</h3>
<p><strong>The CSS-in-JS approach:</strong> Props, theme providers, and runtime style injection.</p>
<pre><code language="jsx"><strong>const</strong> <b>Card</b> <i>=</i> styled<i>.</i>div<i>`</i>
  <b>padding</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> props<i>.</i>compact <i>?</i> <em>'0.5rem'</em> <i>:</i> <em>'1rem'</em><i>}</i><i>;</i>
  <b>background</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> props<i>.</i>theme<i>.</i>surface<i>}</i><i>;</i>
  <b>border-radius</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> props<i>.</i>theme<i>.</i>radius<i>}</i><i>;</i>
<i>`</i>

<i>&lt;</i><strong>ThemeProvider </strong><b>theme</b><i>=</i><i>{</i>darkTheme<i>}</i><i>&gt;</i>
  <i>&lt;</i><strong>Card </strong>compact primary<i>&gt;</i>Content<i>&lt;</i><i>/</i><strong>Card</strong><i>&gt;</i>
<i>&lt;</i><i>/</i><strong>ThemeProvider</strong><i>&gt;</i></code></pre>
<p><strong>Modern CSS approach:</strong> Custom properties and data attributes.</p>
<pre><code language="css"><i>.</i>card <i>{</i>
  <b>padding</b><i>:</i> <strong>var</strong><i>(</i><em>--card-padding</em><i>,</i> <strong>var</strong><i>(</i><em>--space-4</em><i>)</i><i>)</i><i>;</i>
  <b>background</b><i>:</i> <strong>var</strong><i>(</i><em>--surface-color</em><i>)</i><i>;</i>
  <b>border-radius</b><i>:</i> <strong>var</strong><i>(</i><em>--radius</em><i>)</i><i>;</i>
<i>}</i>

<i>.</i><b>card</b><i>[</i>data<i>-</i>compact<i>]</i> <i>{</i>
  <em>--card-padding</em><i>:</i> <strong>var</strong><i>(</i><em>--space-2</em><i>)</i><i>;</i>
<i>}</i></code></pre>
<pre><code language="html"><i>&lt;</i><strong>div </strong><b>class</b><i>=</i><em>"card"</em> data<i>-</i>compact <b>style</b><i>=</i><em>"--surface-color: var(--dark-surface)"</em><i>&gt;</i>
  Content
<i>&lt;</i><i>/</i><strong>div</strong><i>&gt;</i></code></pre>
<p>No theme providers needed. No prop drilling. No runtime style computation. Just CSS doing what it was designed to do.</p></section>

<section><h2>Performance that matters</h2>
<p>CSS-in-JS adds overhead at every level. Parse JavaScript. Execute functions. Generate styles. Inject into DOM. Compare that to CSS which browsers optimize at the engine level.</p>
<div class="columns"><p><strong>Runtime overhead</strong> happens with every render. CSS-in-JS libraries must parse template literals, execute functions, and inject styles during the component lifecycle. This work repeats for every component instance.</p>
<figure><div style="--height:200px;"></div></figure>
<p><strong>Bundle bloat</strong> means larger downloads. Styled-components adds 42KB. Emotion adds 35KB. Both require React as a peer dependency. Meanwhile, your entire CSS design system weighs 4KB and works with any HTML.</p>
<figure class="blue"><div style="--height:200px;"></div></figure></div>
<p>The performance difference becomes dramatic at scale. CSS loads once and browsers cache it forever. CSS-in-JS processes styles on every page load, every route change, every component update.</p></section>

<section><h2>The maintenance trap</h2>
<p>CSS-in-JS creates vendor lock-in disguised as developer experience. Your styles become JavaScript code that only works with specific libraries and build tools.</p>
<pre><code language="jsx"><sup>// This only works with styled-components</sup>
<strong>const</strong> <b>Button</b> <i>=</i> styled<i>.</i>button<i>.</i><b>attrs</b><i>(</i><b>props</b> <i>=</i><i>&gt;</i> <i>(</i><i>{</i>
  <b>type</b><i>:</i> props<i>.</i>type <i>|</i><i>|</i> <em>'button'</em>
<i>}</i><i>)</i><i>)</i><i>`</i>
  <b>background</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> props<i>.</i>theme<i>.</i>colors<i>.</i>primary<i>}</i><i>;</i>
  <b>transition</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> props<i>.</i>theme<i>.</i>transitions<i>.</i>fast<i>}</i><i>;</i>

  <i>&</i><i>:</i>hover <i>{</i>
    <b>background</b><i>:</i> <i>$</i><i>{</i><b>props</b> <i>=</i><i>&gt;</i> <b>darken</b><i>(</i><em>0.1</em><i>,</i> props<i>.</i>theme<i>.</i>colors<i>.</i>primary<i>)</i><i>}</i><i>;</i>
  <i>}</i>
<i>`</i></code></pre>
<p>When you need to migrate frameworks or update dependencies, you rewrite everything. The CSS knowledge doesn't transfer. The components don't work elsewhere.</p>
<p>Compare this to semantic CSS:</p>
<pre><code language="css">button <i>{</i>
  <b>background</b><i>:</i> <strong>var</strong><i>(</i><em>--primary-600</em><i>)</i><i>;</i>
  <b>transition</b><i>:</i> <strong>var</strong><i>(</i><em>--transition-fast</em><i>)</i><i>;</i>
<i>}</i>

<b>button</b><i>:</i>hover <i>{</i>
  <b>background</b><i>:</i> <strong>var</strong><i>(</i><em>--primary-700</em><i>)</i><i>;</i>
<i>}</i></code></pre>
<p>This CSS works with React, Vue, Svelte, or vanilla HTML. It works today and will work in 10 years. No migration needed when you change frameworks. No rewriting when libraries update.</p></section>

<section><h2>Design system anti-patterns</h2>
<p>CSS-in-JS encourages patterns that fragment design systems. Every component becomes a styling decision point. Designers lose control over the visual language.</p>
<pre><code language="jsx"><sup>// Styling scattered across components</sup>
<strong>const</strong> <b>HeaderButton</b> <i>=</i> styled<i>.</i>button<i>`</i>
  <b>background</b><i>:</i> <i>#</i><em>3b82f6</em><i>;</i>
  <b>border-radius</b><i>:</i> <em>6px</em><i>;</i>
<i>`</i>

<strong>const</strong> <b>SidebarButton</b> <i>=</i> styled<i>.</i>button<i>`</i>
  <b>background</b><i>:</i> <i>#</i><em>2563eb</em><i>;</i>
  <b>border-radius</b><i>:</i> <em>4px</em><i>;</i>
<i>`</i>

<strong>const</strong> <b>FooterButton</b> <i>=</i> styled<i>.</i>button<i>`</i>
  <b>background</b><i>:</i> <i>#</i><em>1d4ed8</em><i>;</i>
  <b>border-radius</b><i>:</i> <em>8px</em><i>;</i>
<i>`</i></code></pre>
<p>Each button has slightly different colors and border radius. The design system fragments because styling decisions happen in isolation. Consistency requires vigilant code review and shared constants that developers often ignore.</p>
<p>CSS design systems prevent this fragmentation:</p>
<pre><code language="css">button <i>{</i>
  <b>background</b><i>:</i> <strong>var</strong><i>(</i><em>--primary-600</em><i>)</i><i>;</i>
  <b>border-radius</b><i>:</i> <strong>var</strong><i>(</i><em>--radius</em><i>)</i><i>;</i>
<i>}</i></code></pre>
<p>One source of truth. Consistent everywhere. Designers control the system through CSS variables. Developers use semantic HTML without making visual decisions.</p></section>

<section><h2>Real CSS solutions</h2>
<p>Modern CSS provides clean solutions for every problem CSS-in-JS tries to solve:</p>
<p><strong>Custom properties</strong> replace JavaScript variables with better performance and browser optimization.</p>
<p><strong>Cascade layers</strong> eliminate specificity conflicts more elegantly than generated class names.</p>
<p><strong>Container queries</strong> make components responsive without JavaScript media query libraries.</p>
<p><strong>Logical properties</strong> handle internationalization better than CSS-in-JS direction utilities.</p>
<p><strong>Native nesting</strong> provides the syntax benefits without build complexity.</p>
<p>These aren't workarounds or polyfills. They're native browser features optimized at the engine level.</p></section>

<section><h2>Choose your complexity</h2>
<p>CSS-in-JS asks you to accept JavaScript complexity to solve CSS problems. Modern CSS asks you to learn CSS features to solve CSS problems directly.</p>
<p>The complexity you choose shapes your entire development experience. CSS-in-JS complexity grows with your application. CSS complexity stays constant because the browser handles optimization.</p>
<p>When you bet on web standards instead of JavaScript abstractions, your investment compounds over time. Your CSS skills apply everywhere. Your design systems outlast framework changes. Your performance improves as browsers optimize further.</p>
<p>CSS didn't get worse when CSS-in-JS emerged. CSS got better while we were looking elsewhere. It's time to look back.</p></section>
      
    </article>
  
      
    </main>
  
      <footer>
  © 2026 <div class="logo"><b>■</b> Shubham Mete
</div> <nav></nav></footer>
      
    </body>
  
    </html>
  